I"Æ#<p>I concluded a <a href="/powershell/2019/02/04/ALittleBitAboutPowerShell/">previous post</a> discussing some tidbits about PowerShell with the comment that you should make good use of your $profile.</p>

<p>So what‚Äôs $profile? Let‚Äôs see:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; $profile
C:\Users\mtreit\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre></div></div>

<p>It‚Äôs simply a string that points to a profile script that is automatically executed when you launch PowerShell, as long as you don‚Äôt pass the -NoProfile switch. By default the script file it points to will not exist, but of course it‚Äôs simple to create one:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; New-Item $profile
Directory: C:\Users\mtreit\Documents\WindowsPowerShell

Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a----         2/5/2019   7:11 PM          0 Microsoft.PowerShell_profile.ps1
</code></pre></div></div>

<p>I said the script is automatically executed when you launch PowerShell. Technically it‚Äôs actually ‚Äòdot sourced‚Äô, which means the context in which the script executes is the current context. Normally if you execute a PowerShell script it gets it‚Äôs own context, which goes away after the script completes. This means variables, functions and other entities defined in the script do not persist. By dot sourcing, entities defined in the script will be persisted into the current context. The upshot of this is that functions defined in your $profile script will be pulled into your current PowerShell session and available for you to use.</p>

<p>You can dot source a script at any time using, well, the ‚Äòdot‚Äô or period character:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; . $profile
</code></pre></div></div>

<p>Of course in the example snippets above, we know our current $profile is empty so this is a no-op.</p>

<p>Open $profile in your favorite editor and you can start adding useful functions. Some PowerShell purists will undoubtedly insist that your functions should follow the PowerShell standard conventions of using common nouns and verbs to compose the names; that‚Äôs all well and good if it makes you happy, but your $profile is very personal. In my opinion it should reflect your individual style and aesthetic taste.</p>

<p>For me, that means brevity. Conciseness is a virtue when working on the command line, and while I think PowerShell proper (meaning the cmdlets that come along with it) errs on the right side by using highly organized and descriptive names such as <code><code>Get-ChildItem</code></code> and <code>Invoke-WebRequest</code> and the like, it also provides aliases and shorthand versions for many of these for a reason. Nobody wants to do that much typing.</p>

<p>Here are a few trivial little PowerShell functions that exist in my $profile and which I use almost every day:</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="kr">function</span><span class="w"> </span><span class="nf">gt</span><span class="w">
</span><span class="p">{</span><span class="w">
    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="bp">$args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nf">Push-Location</span><span class="w"> </span><span class="p">(</span><span class="nf">Split-Path</span><span class="w"> </span><span class="bp">$args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kr">function</span><span class="w"> </span><span class="nf">spop</span><span class="w">
</span><span class="p">{</span><span class="w">
    </span><span class="kr">while</span><span class="w"> </span><span class="p">((</span><span class="nf">Get-Location</span><span class="w"> </span><span class="nt">-stack</span><span class="p">)</span><span class="o">.</span><span class="nf">Count</span><span class="w"> </span><span class="o">-gt</span><span class="w"> </span><span class="nx">0</span><span class="p">)</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nf">popd</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kr">function</span><span class="w"> </span><span class="nf">g</span><span class="w"> </span><span class="p">{[</span><span class="kt">guid</span><span class="p">]::</span><span class="nf">NewGuid</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">%</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">Guid</span><span class="p">}}</span></code></pre></figure>

<p>The first function, gt, which stands for ‚Äògo-to‚Äô, is probably one of my favorite little inventions to make my daily life easier. As you can see, it takes a path as input, runs it through the Split-Path cmdlet, then changes to that location. Split-Path, by default, returns all but the last part of a given path, so it is highly useful for getting the folder name a file resides in. That‚Äôs exactly what it‚Äôs used for here: given a file name, it moves you to the folder where that file lives.</p>

<p>Let‚Äôs say I am building my source code tree and a specific project, c:\somecode\projectX\projectX.csproj fails. I just double-click that path in the build output, right-click (which, due to having QuickEdit on in my console settings copies the path to the clipboard) then type gt <space> <right-click> <Enter>and I'm right where the file lives so I can start working on the problem. In practice it takes no time at all. Quite useful.</Enter></right-click></space></p>

<p>Also, because this function uses Push-Location (aka, pushd), I can fix the problem and then return to where I was with a simple popd (or Pop-Location) command.</p>

<p>Incidentally, if you don‚Äôt use pushd and popd to move around on the command-line, you‚Äôre doing it wrong! Using cd, or Set-Location, is usually a waste because it does not give you a nice way to jump backwards. It‚Äôs sort of like navigating the web in your browser without a back button. If you get used to using the location stack and pushing and popping your way around you will be much happier.</p>

<p>Which brings us to my second trivial little function, spop, (super pop) which unwinds the location stack. Sometimes you‚Äôve pushed and pushed and pushed your way down a deep rat-hole of folders and you just want to unwind the whole mess and get back to where you started, clean up the location stack and start fresh.</p>

<p>Finally there is the trivial little g function, which generates a Guid. I don‚Äôt know about you, but I often need to generate Guids and I can do it in two key-presses (g <Enter>) from my ever-present PowerShell window. None of this overkill nonsense:</Enter></p>

<p><img src="/images/guid1.png" alt="Guid Overkill" /></p>

<p>I mean, I can appreciate that Visual Studio has this nice mechanism to generate Guids in all of these possible formats, but in my daily development life I nearly always just want the normal ‚Äò78a12142-7c88-482d-8563-800617f0fc8f‚Äô type of format with no curly braces, an option which the tool above does not even provide. (I love that the default option above is the IMPLEMENT_OLECREATE one. Presumably this was useful at some point in the distant past of writing COM servers, but I‚Äôm guessing it‚Äôs not the one most developers are looking for.)</p>

<p>Anyway, I just type ‚Äòg‚Äô.</p>

<p>The point of all this isn‚Äôt that you should use these same functions, although you might find them useful to add to your $profile, but rather to show that you can make your life so much easier by building up your own library of trivial little PowerShell functions to make those day-to-day tasks just a bit faster, and easier, and more fun!</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="kr">function</span><span class="w"> </span><span class="nf">flip</span><span class="w"> 
</span><span class="p">{</span><span class="w"> 
    </span><span class="nf">Set-Clipboard</span><span class="w"> </span><span class="s2">"(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª"</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="kr">function</span><span class="w"> </span><span class="nf">shrug</span><span class="w">
</span><span class="p">{</span><span class="w"> 
    </span><span class="nf">Set-Clipboard</span><span class="w"> </span><span class="s2">"¬Ø\_(„ÉÑ)_/¬Ø"</span><span class="w">
</span><span class="p">}</span></code></pre></figure>
:ET